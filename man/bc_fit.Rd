% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/boxcox.R
\name{bc_fit}
\alias{bc_fit}
\title{Lambda selection and application of the boxcox transformation.}
\usage{
bc_fit(l_lambda, y, data, mu_mod = ~1, sig2_mod = ~1, time_var,
  ci_p = 0.95, to_plot = FALSE)
}
\arguments{
\item{l_lambda}{a vector of lambda value  the profile likelihood will be computed at.}

\item{y}{a univarite time-serie.}

\item{data}{a data.frame with the values for the covariates used to model the mean and the variance of the gaussian variables.}

\item{mu_mod}{a formula giving the list of covariates the mean parameter of the gaussians depends on.}

\item{sig2_mod}{a formula giving the list of covariates the variabces parameter of the gaussians depends on}

\item{time_var}{the variable used as time for the time serie.}

\item{ci_p}{the level of the confidence intervals wanted.}

\item{to_plot}{whether to plot the profile likelihood.}
}
\value{
returns a list with the arguments of the function as well as :
\itemize{
\item y_eml, the original time serie normalize by  \code{exp(mean(log(y)))}.
\item y_lambda, the original time serie using to the boxcox transformation .
\item y_std, the standardized time serie.
\item mu_fit, the linear model fitted for the trend.
\item sig2_fit, the linear model fitted for the variance.
}
}
\description{
Select a lambda and apply the boxcox transformation to make rhe data more gaussian.
}
\details{
The selection is lambda is done using the profile likelihood method. The aims is to find the lambda which maximize the likelihood of independant gaussian variables. The mean and the variance of the gaussian variables can be modelled as being linearly dependent on a specified set of covariates. The data are first normalized by \code{exp(mean(log(y)))} to make the optimization step easier.
}
\examples{
data(tas)
eur_tas_positive <- with(tas, eur_tas + abs(min(eur_tas)) +1)
y_bc <- bc_fit(l_lambda=seq(-1, 1, 0.02), y=eur_tas_positive, data=tas, mu_mod=~avg_gbl_tas, sig2_mod=~avg_gbl_tas, time_var="year", to_plot=TRUE)
y_bc_fit <- gpd_fit(y_bc$y_std ,  data=tas, time_var="year", qthreshold=0.8)
t1 <- 2003
t0 <- 1990
xp <- 1.6
pnt1 <- set_pnt(t1, xp, time_var="year", tas)
pnt0 <- set_pnt(t0, xp, time_var="year", tas)
get_far(y_bc, y_bc_fit, pnt0, pnt1, under_threshold=TRUE)
\donttest{ boot_ic(y_bc,  y_bc_fit, xp, t0, t1, under_threshold=TRUE)}
}

